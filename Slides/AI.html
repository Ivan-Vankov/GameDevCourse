<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title id="page-title">Game Dev Presentation</title>
		<link rel="icon" href="images/Unity-Icon.png">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="RevealJS/css/reset.css">
		<link rel="stylesheet" href="RevealJS/css/reveal.css">
		<link rel="stylesheet" href="RevealJS/css/custom.css">
		<link rel="stylesheet" href="RevealJS/css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="RevealJS/lib/css/vs2015.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'RevealJS/css/print/pdf.css' : 'RevealJS/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="RevealJS/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<a href="https://github.com/Ivan-Vankov/GameDevCourse#readme">
				<i id="next-exercise" class="fas fa-arrow-circle-right navigation-button next-exercise"></i>
			</a>
			<a href="./Animation.html">
				<i id="previous-exercise" class="fas fa-arrow-circle-left navigation-button previous-exercise"></i>
			</a>

			<div class="slides">
				<section>
					<h2 id="slides-title">Artificial Inteligence</h2>
					<img width="200" height="200" data-src="images/Unity-Logo.png" alt="Unity Logo">
				</section>

				<section>
					<h2>Are we recording?</h2>
					<img width="300" height="300" data-src="images/Cat-Cam.png" alt="Meow Cam">
				</section>

				<section>
					<h3>Review</h3>

					<p>What is Skeletal Animation?</p>
					<ul>
						<li class="fragment">A rig made of bones is used</li>
						<li class="fragment">
							Each bone associates with the vertices of the mesh 
							around it with a certain weight
						</li>
						<li class="fragment">
							Keyframes are made with the bones 
							in different positions
						</li>
						<li class="fragment">
							Animation is done by interpolationg 
							between the keyframes
						</li>
					</ul>
				</section>

				<section>
					<h3>Review</h3>

					<p>What is Sprite Sheet Animation?</p>
					<ul>
						<li class="fragment">
							Similar versions of the same sprite are 
							displayed one after the other creating motion
						</li>
					</ul>
				</section>

				<section>
					<h3>Review</h3>

					<p>How does the Unity Animator work?</p>
					<ul>
						<li class="fragment">Operates like a finite state automaton</li>
						<li class="fragment">Each state is an animation</li>
						<li class="fragment">
							Edges between states describe under what condition 
							the animation change will occur and how
						</li>
					</ul>
				</section>

				<section>
					<h3>AI Definition</h3>

					<p>
						An agent that can perceives its environment and takes actions 
						based on its perception to successfully achieving its goals
					</p>
				</section>

				<section>
					<h3>Regular AI vs Game AI</h3>

					<ul>
						<li>Regular AI aims to maximize its chance of success</li>
						<li>Game AI aims to maximize the fun factor of a game
							<ul>
								<li>Playing agains a bot that does perfect moves every turn isn't fun</li>
							</ul>
						</li>
					</ul>
                </section>

				<section>
					<h3>Uses of AI in games</h3>

					<ul>
						<li>Pathfinding</li>
						<li>Decision making
							<ul>
								<li>Combat AI</li>
								<li>Villagers going about their day in Skyrim</li>
							</ul>
						</li>
						<li>Procedural content generation
							<ul>
								<li>Procedural levels in Spelunky</li>
								<li>World generation in Minecraft</li>
							</ul>
						</li>
						<li><a href="https://www.youtube.com/watch?v=cUTMhmVh1qs">Being the best StarCraft player in the world</a></li>
					</ul>
				</section>
				
				<section>
					<h3>Pathfinding</h3>

					<ul>
						<li>You have a character</li>
						<li>It needs to go from point A to point B</li>
						<li>There may be obstacles</li>
						<li>The character may not fit through gaps</li>
					</ul>
                </section>

				<section>
					<h3>Waypoint Graph</h3>

					<ul>
						<li>You have a level</li>
						<li>You break it up into a graph of waypoints</li>
						<li>Each waypoint marks a walkable location</li>
						<li>Edges denote that the area near them has no obstacles</li>
					</ul>

					<img height="200" src="images/Waypoint_Graph.gif">
				</section>
				
				<section>
					<h3>Pathfinding Algorithms</h3>

					<ul>
						<li>DFS</li>
						<li>BFS</li>
						<li>Dijkstra</li>
						<li>A* ❤️</li>
						<li>
							<a href="https://theory.stanford.edu/~amitp/GameProgramming/Variations.html">
								... Many others
							</a>
						</li>
					</ul>
                </section>

				<section>
					<h3>DFS (Depth first search)</h3>

					<ul>
						<li>Useful for traversing graphs with a large branching factor and low height</li>
						<li>Inefficient for finding shortest path</li>
						<li>Goes as deep as possible before backtracking (returning to parent nodes)</li>
					</ul>
                </section>

				<section>
					<h3>BFS (Breath first search)</h3>

					<ul>
						<li>Can find the shortest path in unweighted graphs</li>
						<li>Traverses the graph by levels</li>
						<li>May use way too much memory</li>
					</ul>
                </section>
				 
				<section>
					<h3>Dijkstra</h3>

					<ul>
						<li>Finds the shortest path from one point to every other point in a weighted graph</li>
						<li>Every point is initialy infinately far from the starting point</li>
						<li>At every step we add the closest to the start unvisited point</li>
					</ul>

					<img src="images/dijkstra.gif"></img>
				</section>

				<section>
					<h3>A*</h3>

					<ul>
						<li>At every step we choose the node with smallest value f(n) = g(n) + h(n)</li>
						<li>g(n) is the distance from the starting node to the current node n</li>
						<li>h(n) is the heurestic that gives a distance from n to the goal node</li>
						<li>Heurestic means that it is good enough but not always guranteed to be correct
							<ul>
								<li>Used when the original function is difficult to compute</li>
							</ul>
						</li>
					</ul>
                </section>
                
				<section>
					<h3>A* Details</h3>

					<ul>
						<li>Much faster than Dijkstra for finding the shortest path between exactly two points</li>
						<li>Is always correct if the heurestic function underestimates the real value</li>
						<li>
							Example heurestic functions:
							<ul>
								<li>Euclidian distance</li>
								<li>Manhattan distance(if we can't move diagonaly)</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h3>A* Demo</h3>

					<img height="400" src="images/astar.gif"></img>
				</section>
				
				<section>
					<h3>A* Code</h3> 

					<pre>
						<code>
openSet = empty set of nodes
add startNode to openSet
closedSet = empty set of nodes

while openSet is not empty
  current = node in openSet with min fCost
  remove current from openSet

  if current == final
    return

  for neighbour in neighbours of current
	if (neighbour is an obstacles 
	    or neighbour is in closedSet)
	  continue
	
	if (new path to neighbour has a lower fScore 
		or neighbour is not in openSet)
	  set improved fCost of neighbour
	  set parent of neighbour to current
	  if neighbour is not in openSet
	    add neighbour to openSet
					</code>
				</pre>
                </section>
                
				<section>
					<h3>Navigation Meshes (NavMesh)</h3>

					<ul>
						<li>А collection of 2D convex polygons that 
							define which areas of an environment are traversable by an agent</li>
						<li>The polygons are the graphs vertices</li>
						<li>An edge between two polygons exists if they are adjacent</li>
					</ul>
				</section>
				
				<section>
					<h3>NavMesh vs Waypoint Graph</h3>

					<img height="400" src="images/Waypoint_Graph_vs_NavMesh.gif">
                </section>
                
				<section>
					<h3>NavМeshes in Unity</h3>

					<ul>
						<li>Agents are represented as cylinders
							<ul>
								<li>Found in Window/AI/Navigation/Agents</li>
							</ul>
						</li>
						<li>Most components are located in a 
							<a href="https://github.com/Unity-Technologies/NavMeshComponents">
								separate repo
							</a>
						</li>
					</ul>

					<img height="300" src="images/NavMesh.png">
				</section>
				
				<section>
					<h3>NavМeshe Live Demo</h3>
                </section>

				<section>
					<h3>State Machine AI</h3>

					<ul>
						<li>Each state represents a behaviour for the AI</li>
						<li>Each edge represents a change of world state</li>
					</ul>

					<img height="350" src="images/State_Machine_AI.png">
                </section>
                
				<section>
					<h3>Unity State Machine AI</h3>

					<ul>
						<li>Integrated with the Animator</li>
						<li>Each state can have several attached StateMachineBehaviours</li>
						<li>A StateMachineBehaviours has:
							<ul>
								<li>OnStateEnter</li>
								<li>OnStateUpdate</li>
								<li>OnStateExit</li>
							</ul>
						</li>
					</ul>
                </section>
                                
				<section>
					<h3>Unity State Machine AI Live Demo</h3>
				</section>
				
				<section>
                    <h3>Extra Resources</h3>
					
					<ul>
						<li>
							<a href="https://www.youtube.com/watch?v=-L-WgKMFuhE&list=PLFt_AvWsXl0cq5Umv3pMC9SPnKjfp9eGW">
								A*
							</a>
						</li>
						<li>
							<a href="https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/">
								NavMeshes and Pathfinding Theory
							</a>
						</li>
						<li>
							<a href="https://www.youtube.com/watch?v=CHV1ymlw-P8&list=PLE7Of16Aa0jA6WsAvY7IpQPsh-MDAGqSN&index=2&t=0s">
								NavMeshes in Unity Tutotial
							</a>
						</li>
						<li>
							<a href="https://docs.unity3d.com/Manual/nav-InnerWorkings.html">
								NavMeshes in Unity Documentationn
							</a>
						</li>
					</ul>
					
					<script>
						console.log(document.getElementById("next-exercise"));
						document.getElementById("next-exercise").style.visibility = "hidden";
					</script>
                </section>
                
				<section data-state="next-exercise">
					<h3>Questions?</h3>

					<img height="300" data-src="images/Question-Cat-6.png" alt="Question Cat">

					<script>
						document.getElementById("next-exercise").style.visibility = "visible";
					</script>
				</section>
			</div>
		</div>

		<a href="https://github.com/Ivan-Vankov/GameDevCourse#readme">
			<i class="fa fa-home navigation-button home"></i>
		</a>	

		<div id="slides-title-div">
			<p id="slides-title-meta">AI</p>
			<script>
				var slides_title = document.getElementById("slides-title").innerHTML;
				document.getElementById("page-title").innerHTML = slides_title;
			</script>
		</div>

        <script src="RevealJS/js/setup-exercise-navigation.js"></script>

		<script src="RevealJS/js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,
				mouseWheel: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'RevealJS/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'RevealJS/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'RevealJS/plugin/highlight/highlight.js' },
					{ src: 'RevealJS/plugin/search/search.js', async: true },
					{ src: 'RevealJS/plugin/zoom-js/zoom.js', async: true },
					{ src: 'RevealJS/plugin/notes/notes.js', async: true },
					{ src: 'RevealJS/plugin/menu/menu.js', async: true }
				]
			});

			Reveal.configure({ slideNumber: 'c/t' });

			Reveal.addEventListener('hide-exercise-navigation-arrows', function() {
				document.getElementById('next-exercise').style.visibility = 'hidden';
				document.getElementById('previous-exercise').style.visibility = 'hidden';
			});

			Reveal.addEventListener('show-left-exercise-navigation-arrow', function() {
				let previousExerciseButton = document.getElementById('previous-exercise');
				previousExerciseButton.classList.add('fade-in');
				setTimeout(() => {
					previousExerciseButton.classList.remove('fade-in');
				}, 500);
				document.getElementById('next-exercise').style.visibility = 'hidden';
				previousExerciseButton.style.visibility = 'visible';
			});

			Reveal.addEventListener('show-right-exercise-navigation-arrow', function() {
				let nextExerciseButton = document.getElementById('next-exercise');
				nextExerciseButton.classList.add('fade-in');
				setTimeout(() => {
					nextExerciseButton.classList.remove('fade-in');
				}, 500);
				nextExerciseButton.style.visibility = 'visible';
				document.getElementById('previous-exercise').style.visibility = 'hidden';
			});

			// Set the theme to a combination of blood and black
			document.getElementById('theme').setAttribute('href','RevealJS/css/theme/custom_theme.css'); 
		</script>

	</body>
</html>
